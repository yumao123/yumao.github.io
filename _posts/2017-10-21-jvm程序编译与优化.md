---
title: Jvm程序编译与优化
description: Null
categories:
 - java
photos:
tags:
- Tomcat
---

> 关于Jvm程序编译与优化
![实力至上]({{ site.url }}/assets/images/201710/1018_top.png)

## 解析与填充符号表
编译过程的过程<br/>
解析与填充符号表 - 插入式注解处理器的注解处理 - 分析与字节码生成<br/>
- 词法 & 语法解析
词法解析:将源码字符流转为标记(token)集合
```
int a = b + 2 -> 6个标记
```
语法解析:通过Token集合构造抽象语法树<br/>
语法树:每一个节点代表程序代码中的一个语法结构<br/>
- 填充符号表
符号表:类似k-v值对，等级的信息在编译不同阶段都使用

## 注解处理器

## 语义分析&字节码生成
- 标注检查
检查内容包含变量是否已生命，赋值之间的数据类型是否匹配，常量折叠
```
常量折叠
int a = 1 + 2; -> 折叠后 int a = 3; 两个在运行期对cpu指令运算量没有影响
```
- 数据控制流分析
对程序上下文逻辑进一步验证，比如局部变量使用前是否赋值，异常是否被正确处理等
```
public void fool(final int arg){
	final int var = 0;
}
编译出来的class文件是没有final的，因为局部变量在常量池中没有访问标志 -> 所以局部变量有没有final并不影响运行期
```
- 解语法糖
- 字节码生成
不但将语法数/符号表转化为字节码，还进行了少量代码添加和转换，比如<clinit>() & <init>()
<clinit>():如果没有提供构造函数，编译器默认添加

## 关于语法糖
- 泛型与类型擦除
```
public void test(List<String>){}
public void test(List<Integer>){}
上面两个同时存在是不能通过编译的，但是如下可以
public String test(List<String>){}
public Integer test(List<Integer>){}
因为虽然函数的特征签名与名称一致，但是返回值不同，可以合法的共存在一个Class文件中
```
- 自动装箱/拆箱/遍历循环
```
List<Integer> list = Arrays.asList(1,2,3,4);
int sum = 0;
for (int i: list){
  sum += 1;
}
->经历泛型/自动装箱/拆箱/遍历循环
List list = Arrays.asList(new Integer[](
	Integer.valueOf(1),Integer.valueOf(2),Integer.valueOf(3),Integer.valueOf(4)
));
int sum = 0;
for(Iterator localIterator = list.iterator(); localIterator.hasNext();){
	int i = ((Integer)localIterator.next()).intValue();
	sum += i;
}
这里将遍历循环还原成迭代器，所以如果要循环遍历的类需要实现Iterable接口
```
- 条件编译
编译器会将分支中不成立的代码块消除
```
if (false){
	dosomething()
}
```