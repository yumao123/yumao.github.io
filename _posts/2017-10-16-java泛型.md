---
title: Java反射
description: Null
categories:
 - tutorial
photos:
tags:
- Jvm
---

> Java泛型解惑篇.
![花火!]({{ site.url }}/assets/images/201710/1017_top.png)

## 关于泛型类
```java
public class Box {
    private String object;
    public void set(String object) { this.object = object; }
    public String get() { return object; }
}
```
如上，当前Box只支持String类型，如果以后要修改为int类型，则需要修改这个类或者新增一个类，那么泛型就起到作用了
```java
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
正式使用:
Box<Integer> integerBox = new Box<Integer>();
Box<Double> doubleBox = new Box<Double>()
如果涉及多种类型，那么只要
public class Box<T,V>就好了.
Box<Integer,String>
```

## 关于泛型方法
声明泛型方法也比较简单，上面已经包含了，只要在返回值前加上类似<T,V>这样就可以了
```java
public class Util {
    public static <K, V> boolean compare(Box<K, V> p1, Box<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}
```

## 关于边界符
为什么泛型要搞个边界符呢，如下
```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem)  // compiler error
            ++count;
    return count;
}
```
如果T的类型不能通过>对比大小，所以编译器会报错
```java
Demo.java:25: 错误: 二元运算符 '>' 的操作数类型错误
                if (e > elem)  // compiler error
                      ^
  第一个类型:  T
  第二个类型: T
  其中, T是类型变量:
    T扩展已在方法 <T>countGreaterThan(T[],T)中声明的Object
```
为了避免这种方法，我们必须要保证T的类型是可以通过>比对的，也就是T必须要实现Comparable接口
```java
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)
            ++count;
    return count;
}
```
