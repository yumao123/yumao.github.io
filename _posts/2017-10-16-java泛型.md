---
title: Java泛型
description: Null
categories:
 - tutorial
photos:
tags:
- Jvm
---

> Java泛型解惑篇.
![实力至上]({{ site.url }}/assets/images/201710/1018_top.png)

## 关于泛型类
```java
public class Box {
    private String object;
    public void set(String object) { this.object = object; }
    public String get() { return object; }
}
```
如上，当前Box只支持String类型，如果以后要修改为int类型，则需要修改这个类或者新增一个类，那么泛型就起到作用了
```java
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
正式使用:
Box<Integer> integerBox = new Box<Integer>();
Box<Double> doubleBox = new Box<Double>()
如果涉及多种类型，那么只要
public class Box<T,V>就好了.
Box<Integer,String>
```

## 关于泛型方法
声明泛型方法也比较简单，上面已经包含了，只要在返回值前加上类似<T,V>这样就可以了
```java
public class Util {
    public static <K, V> boolean compare(Box<K, V> p1, Box<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}
```

## 关于边界符
为什么泛型要搞个边界符呢，如下
```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem)  // compiler error
            ++count;
    return count;
}
```
只有java的标准数据类型才能通过>对比，所以编译器会报错
```java
Demo.java:25: 错误: 二元运算符 '>' 的操作数类型错误
                if (e > elem)  // compiler error
                      ^
  第一个类型:  T
  第二个类型: T
  其中, T是类型变量:
    T扩展已在方法 <T>countGreaterThan(T[],T)中声明的Object
```
为了避免这种方法，我们必须要保证T实现了Comparable接口，通过compareTo(T o)对比大小
```java
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)
            ++count;
    return count;
}
```
extends T:限定参数类型的上界：参数类型必须是T或T的子类型</br>
super T:限定参数类型的下界：参数类型必须是T或T的超类型</br>

## 通配符
```java
public void boxTest(Box<Number> n) { /* ... */ }
```
此时参数既不能接受Box<Integer>或者Box<Double>，因为Box<Integer>或者Box<Double>与Box<Number>之间并没有任何的关系</br>
通过通配符?表示所有类型
```java
// 正解
public void boxTest(Box<?> n) { /* ... */ }
```
```
1.无限定通配符,<?>。
2.上限通配符,<? extends Number>。表示参数类型只能是Number的子类。
3.下限通配符,<? supper Number>。表示参数类型只能是Number的父类。
class Reader<T>{
    T read1(List<? extends T>){} // 表示只要read内的参数满足是T的子类即可
    static <E> E read2(List<E> l){} // 另一种解决方案
}
```

## PECS原则
```
List<? extends Person> perons = new ArrayList<Man>();
perons.add(new Man());
Demo.java:38: 错误: 对于add(Man), 找不到合适的方法
                perons.add(new Man());
                      ^
    方法 Collection.add(CAP#1)不适用
      (参数不匹配; Man无法转换为CAP#1)
    方法 List.add(CAP#1)不适用
      (参数不匹配; Man无法转换为CAP#1)
```

如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends)</br>
如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super)</br>
如果既要存又要取，那么就不要使用任何通配符。</br>


